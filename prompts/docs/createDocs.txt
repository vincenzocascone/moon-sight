I'm working on a website that displays the 3D model of the moon in its current phase and gives the possibility to change the date while updating the model. For this project I'm using typescript classes, vite, Three.js for  3D, gsap for animations and tailwind css for style. I will provide some files as examples, write a great documentation for this project that explains the tech stack used, how does the website work and the conventions used for the code.

index.html file:
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="title" content="Moon Sight" />
    <meta name="type" content="website" />
    <meta name="description" content="Check the Current Phase of the Moon" />
    <meta name="author" content="Vincenzo Cascone" />
    <meta name="image" content="/images/preview.png" />
    <meta property="og:image" content="/images/preview.png" />
    <meta
      name="keywords"
      content="Moon, Sight, Phase, Moon Sight, moon, phase, moon phase, Moon Phase, moon phases"
    />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="icon" href="src/assets/favicon.ico" />
    <link
      rel="stylesheet"
      href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@48,400,0,0"
    />
    <script
      src="https://cdn.usefathom.com/script.js"
      data-site="HLUOGYJM"
      defer
    ></script>
    <title>Moon Sight</title>
  </head>
  <body>
    <canvas id="main-canvas"></canvas>
    <div id="loading-bar"></div>
    <div
      id="fullscreen-button"
      class="icon-button icon-button--top-right material-symbols-outlined"
    >
      fullscreen
    </div>
    <a
      class="icon-button icon-button--bottom-right"
      href="https://github.com/Vincenzo117"
    >
      <img src="src/assets/images/github-mark-white.svg" alt="Github Profile" />
    </a>
    <script type="module" src="src/main.ts"></script>
  </body>
</html>


style.scss file:

@tailwind base;
@tailwind components;
@tailwind utilities;

body,
html {
  @apply overflow-hidden;
}

body {
  @apply bg-black;

  #main-canvas {
    @apply fixed w-full h-full outline-none;
  }

  #loading-bar {
    @apply absolute top-1/2 w-full h-1 bg-white transform scale-x-0 origin-top-left transition-transform duration-100;

    &.ended {
      @apply origin-top-right transition-transform duration-150 ease-in-out;
    }
  }

  .icon-button {
    @apply w-6 h-6 z-10 fixed cursor-pointer text-white text-2xl select-none flex items-center justify-center;

    &.icon-button--bottom-right {
      @apply bottom-5 right-5;
    }

    &.icon-button--top-right {
      @apply top-5 right-5;
    }
  }
}

main.ts file:

import "./style.scss";
import Experience from "./experience/Experience";

Experience.getInstance();

Experience.ts file:
import * as THREE from "three";

import Camera from "./Camera";
import Renderer from "./Renderer";
import sources from "./sources";
import DebugUi from "./utils/DebugUi";
import ResourcesManager from "./utils/ResourcesManager";
import StatsPanel from "./utils/StatsPanel";
import TimeManager from "./utils/TimeManager";
import ViewportManager from "./utils/ViewportManager";
import World from "./world/World";

let instance: Experience | null = null;

export default class Experience {
  canvas: HTMLCanvasElement;
  debugUi: DebugUi;
  statsPanel: StatsPanel;
  viewportManager: ViewportManager;
  timeManager: TimeManager;
  scene: THREE.Scene;
  camera: Camera;
  resourcesManager: ResourcesManager;
  renderer: Renderer;
  world: World;

  constructor() {
    if (instance) return instance;
    // eslint-disable-next-line @typescript-eslint/no-this-alias
    instance = this;

    this.debugUi = new DebugUi();
    this.statsPanel = new StatsPanel();
    this.viewportManager = new ViewportManager();
    this.timeManager = new TimeManager();
    this.scene = new THREE.Scene();
    this.camera = new Camera();
    this.resourcesManager = new ResourcesManager(sources);
    this.renderer = new Renderer();
    this.world = new World();

    this.initializeCanvas();
    this.registerEventListeners();
  }

  initializeCanvas() {
    this.canvas = document.getElementById("main-canvas") as HTMLCanvasElement;
    if (!this.canvas) {
      throw new Error("Could not find or create a canvas element.");
    }
  }

  registerEventListeners() {
    this.viewportManager.on("resize", () => this.resize());
    this.timeManager.on("tick", () => this.update());
  }

  resize(): void {
    this.camera.resize();
    this.renderer.resize();
    // this.world.resize();
  }

  update(): void {
    if (this.statsPanel.active) this.statsPanel.instance?.begin();

    this.camera.update();
    this.renderer.update();

    if (this.statsPanel.active) this.statsPanel.instance?.end();
  }
}

Camera.ts file:
import * as THREE from "three";

import Experience from "./Experience.js";

export default class Camera {
  instance: THREE.PerspectiveCamera;

  constructor() {
    const { viewportManager } = Experience.getInstance();

    this.instance = new THREE.PerspectiveCamera(
      45,
      viewportManager.size.width /
        viewportManager.size.height,
      0.1,
      100
    );

    this.setInstance();
  }

  private setInstance() {
    const { scene } = Experience.getInstance();

    this.instance.position.z = 10;
    scene.add(this.instance);
  }

  resize() {
    const { viewportManager } = Experience.getInstance();

    this.instance.aspect =
      viewportManager.size.width /
      viewportManager.size.height;
    this.instance.updateProjectionMatrix();
  }

  update() {
    const { timeManager, viewportManager } = Experience.getInstance();

    if (viewportManager.cursor.position.x) {
      this.instance.position.x +=
        (viewportManager.cursor.position.x - this.instance.position.x) *
        0.005 *
        timeManager.delta;
    } else if (
      viewportManager.orientation.x ||
      viewportManager.orientation.y
    ) {
      this.instance.position.x +=
        (viewportManager.orientation.x - this.instance.position.x) *
        0.01 *
        timeManager.delta;
      this.instance.position.y +=
        (viewportManager.orientation.y - this.instance.position.y) *
        0.005 *
        timeManager.delta;
    }
    this.instance.lookAt(new THREE.Vector3(0, 0, 0));
  }
}

ResourcesManager.ts file:
import gsap from "gsap";
import * as THREE from "three";
import { FontLoader } from "three/examples/jsm/loaders/FontLoader";

import EventEmitter from "./EventEmitter";
import Experience from "../Experience";

export enum SourceType {
  Texture = "texture",
  Font = "font",
}

export interface Source {
  type: SourceType;
  path: string;
  name: string;
}

interface Loaders {
  textureLoader: THREE.TextureLoader;
  fontLoader: FontLoader;
}

export default class ResourcesManager extends EventEmitter {
  private readonly _sources: Source[];
  private _overlay: THREE.Mesh;
  private _loaders: Loaders;
  readonly items: Record<string, any>;

  constructor(sources: Source[]) {
    super();

    this._sources = sources;
    this.items = {};

    this.setOverlay();
    this.setLoaders();
    this.startLoading();
  }

  private setOverlay() {
    const { camera, scene } = Experience.getInstance();
    const overlayGeometry = new THREE.PlaneGeometry(100, 100);
    const overlayMaterial = new THREE.MeshBasicMaterial({
      color: 0x000000,
      transparent: true,
    });
    this._overlay = new THREE.Mesh(overlayGeometry, overlayMaterial);
    this._overlay.position.z = camera.instance.position.z - 0.4;
    scene.add(this._overlay);
  }

  private setLoaders() {
    const loadingBarElement = document.getElementById(
      "loading-bar"
    ) as HTMLElement;

    const loadingManager = new THREE.LoadingManager(
      () => {
        this.trigger("ready");

        gsap.to(this._overlay.material, { duration: 3, opacity: 0, delay: 1 });

        gsap.delayedCall(1, () => {
          loadingBarElement.classList.add("ended");
          loadingBarElement.style.transform = "";
        });
      },
      // @ts-ignore
      (itemUrl, itemsLoaded, itemsTotal) => {
        loadingBarElement.style.transform = `scaleX(${
          itemsLoaded / itemsTotal
        })`;
      },
      (error) => {
        console.error(error);
      }
    );

    this._loaders = {
      textureLoader: new THREE.TextureLoader(loadingManager),
      fontLoader: new FontLoader(loadingManager),
    };
  }

  private startLoading() {
    for (const source of this._sources) {
      if (source.type === SourceType.Texture) {
        this._loaders.textureLoader.load(source.path, (file) => {
          this.sourceLoaded(source, file);
        });
      } else if (source.type === SourceType.Font) {
        this._loaders.fontLoader.load(source.path, (file) => {
          this.sourceLoaded(source, file);
        });
      }
    }
  }

  private sourceLoaded(source: Source, file: any) {
    this.items[source.name] = file;
  }
}

Renderer.ts file:
import * as THREE from "three";

import Experience from "./Experience";

export default class Renderer {
  instance: THREE.WebGLRenderer;

  constructor() {
    const { canvas } = Experience.getInstance();

    this.instance = new THREE.WebGL1Renderer({
      canvas: canvas,
      antialias: true,
    });

    this.resize();
  }

  resize(): void {
    const { viewportManager } = Experience.getInstance();

    this.instance.setSize(
      viewportManager.size.width,
      viewportManager.size.height
    );
    this.instance.setPixelRatio(viewportManager.pixelRatio);
  }

  update(): void {
    const { scene, camera } = Experience.getInstance();

    this.instance.render(scene, camera.instance);
  }
}
