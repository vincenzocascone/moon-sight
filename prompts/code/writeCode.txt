Here is the documentation of the current project that I'm working on followed by some example files of the project, remember this data:

# Moon Sight Documentation

Moon Sight is a web application that displays a 3D model of the moon in its current phase and allows users to change the date while updating the model. The application is built using TypeScript classes, Vite, Three.js for 3D rendering, GSAP for animations, and Tailwind CSS for styling.

## Table of Contents

1. [Overview](#overview)
2. [Tech Stack](#tech-stack)
3. [Key Components](#key-components)
4. [Tasks](#tasks)

## Overview

The Moon Sight web application is designed to provide users with an interactive 3D model of the moon in its current phase. Users can change the date to see how the moon's phase changes over time. The application is built using a combination of modern web technologies and libraries, such as TypeScript, Vite, Three.js, GSAP, and Tailwind CSS.

## Tech Stack

The following technologies and libraries are used in the Moon Sight project:

1. **TypeScript**: TypeScript is a typed superset of JavaScript that compiles to plain JavaScript. It provides static typing and other features to improve the development experience.
2. **Vite**: Vite is a fast build tool and development server for modern web applications. It optimizes the build process and provides features such as hot module replacement for a fast development experience.
3. **Three.js**: Three.js is a JavaScript library used for creating and displaying 3D graphics in the browser using WebGL. In this project, it is used to create the 3D model of the moon and its phases.
4. **GSAP**: GreenSock Animation Platform (GSAP) is a powerful JavaScript library for creating high-performance animations. In this project, it is used to animate the loading bar and other elements.
5. **Tailwind CSS**: Tailwind CSS is a utility-first CSS framework that allows developers to build responsive and modern designs quickly. It is used for styling the application.

## Key Components

The Moon Sight application consists of several key components:

1. **Experience**: This is the main class responsible for initializing the application and managing various components, such as the camera, renderer, resources manager, and world.
2. **Camera**: The Camera class handles the creation and configuration of the Three.js camera instance used to view the 3D scene.
3. **Renderer**: The Renderer class is responsible for managing the WebGL renderer and updating the scene based on user interactions and animations.
4. **ResourcesManager**: This class is responsible for loading and managing resources, such as textures and fonts, required for the application.
5. **World**: The World class is responsible for creating and managing the 3D moon model and handling user interactions with the model.

## Tasks

- Check Orientation Device Sensor
- Refactor World Classes
- Improve World Classes

Here are some example files of the project:

Experience.ts file:
import * as THREE from "three";

import Camera from "./Camera";
import Renderer from "./Renderer";
import sources from "./sources";
import DebugUi from "./utils/DebugUi";
import ResourcesManager from "./utils/ResourcesManager";
import StatsPanel from "./utils/StatsPanel";
import TimeManager from "./utils/TimeManager";
import ViewportManager from "./utils/ViewportManager";
import World from "./world/World";

let instance: Experience | null = null;

export default class Experience {
  canvas: HTMLCanvasElement;
  debugUi: DebugUi;
  statsPanel: StatsPanel;
  viewportManager: ViewportManager;
  timeManager: TimeManager;
  scene: THREE.Scene;
  camera: Camera;
  resourcesManager: ResourcesManager;
  renderer: Renderer;
  world: World;

  constructor() {
    if (instance) return instance;
    // eslint-disable-next-line @typescript-eslint/no-this-alias
    instance = this;

    this.debugUi = new DebugUi();
    this.statsPanel = new StatsPanel();
    this.viewportManager = new ViewportManager();
    this.timeManager = new TimeManager();
    this.scene = new THREE.Scene();
    this.camera = new Camera();
    this.resourcesManager = new ResourcesManager(sources);
    this.renderer = new Renderer();
    this.world = new World();

    this.initializeCanvas();
    this.registerEventListeners();
  }

  initializeCanvas() {
    this.canvas = document.getElementById("main-canvas") as HTMLCanvasElement;
    if (!this.canvas) {
      throw new Error("Could not find or create a canvas element.");
    }
  }

  registerEventListeners() {
    this.viewportManager.on("resize", () => this.resize());
    this.timeManager.on("tick", () => this.update());
  }

  resize(): void {
    this.camera.resize();
    this.renderer.resize();
    // this.world.resize();
  }

  update(): void {
    if (this.statsPanel.active) this.statsPanel.instance?.begin();

    this.camera.update();
    this.renderer.update();

    if (this.statsPanel.active) this.statsPanel.instance?.end();
  }
}

index.html file:
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="title" content="Moon Sight" />
    <meta name="type" content="website" />
    <meta name="description" content="Check the Current Phase of the Moon" />
    <meta name="author" content="Vincenzo Cascone" />
    <meta name="image" content="/images/preview.png" />
    <meta property="og:image" content="/images/preview.png" />
    <meta
      name="keywords"
      content="Moon, Sight, Phase, Moon Sight, moon, phase, moon phase, Moon Phase, moon phases"
    />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="icon" href="/assets/favicon.ico" />
    <link
      rel="stylesheet"
      href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@48,400,0,0"
    />
    <script
      src="https://cdn.usefathom.com/script.js"
      data-site="HLUOGYJM"
      defer
    ></script>
    <title>Moon Sight</title>
  </head>
  <body>
    <canvas id="main-canvas"></canvas>
    <div id="loading-bar"></div>
    <div
      id="fullscreen-button"
      class="icon-button icon-button--top-right material-symbols-outlined"
    >
      fullscreen
    </div>
    <a
      class="icon-button icon-button--bottom-right"
      href="https://github.com/vincenzocascone"
    >
      <img src="/assets/images/github-mark-white.svg" alt="Github Profile" />
    </a>
    <script type="module" src="src/main.ts"></script>
  </body>
</html>

style.scss file:
@tailwind base;
@tailwind components;
@tailwind utilities;

body,
html {
  @apply overflow-hidden;
}

body {
  @apply bg-black;

  #main-canvas {
    @apply fixed w-full h-full outline-none;
  }

  #loading-bar {
    @apply absolute top-1/2 w-full h-1 bg-white transform scale-x-0 origin-top-left transition-transform duration-100;

    &.ended {
      @apply origin-top-right transition-transform duration-150 ease-in-out;
    }
  }

  .icon-button {
    @apply w-6 h-6 z-10 fixed cursor-pointer text-white text-2xl select-none flex items-center justify-center;

    &.icon-button--bottom-right {
      @apply bottom-5 right-5;
    }

    &.icon-button--top-right {
      @apply top-5 right-5;
    }
  }
}

main.ts file:
import "./style.scss";
import Experience from "./experience/Experience";

Experience.getInstance();


Camera.ts file:
import * as THREE from "three";

import Experience from "./Experience.js";

export default class Camera {
  instance: THREE.PerspectiveCamera;

  constructor() {
    const { viewportManager } = Experience.getInstance();

    this.instance = new THREE.PerspectiveCamera(
      45,
      viewportManager.size.width /
        viewportManager.size.height,
      0.1,
      100
    );

    this.setInstance();
  }

  private setInstance() {
    const { scene } = Experience.getInstance();

    this.instance.position.z = 10;
    scene.add(this.instance);
  }

  resize() {
    const { viewportManager } = Experience.getInstance();

    this.instance.aspect =
      viewportManager.size.width /
      viewportManager.size.height;
    this.instance.updateProjectionMatrix();
  }

  update() {
    const { timeManager, viewportManager } = Experience.getInstance();

    if (viewportManager.cursor.position.x) {
      this.instance.position.x +=
        (viewportManager.cursor.position.x - this.instance.position.x) *
        0.005 *
        timeManager.delta;
    } else if (
      viewportManager.orientation.x ||
      viewportManager.orientation.y
    ) {
      this.instance.position.x +=
        (viewportManager.orientation.x - this.instance.position.x) *
        0.01 *
        timeManager.delta;
      this.instance.position.y +=
        (viewportManager.orientation.y - this.instance.position.y) *
        0.005 *
        timeManager.delta;
    }
    this.instance.lookAt(new THREE.Vector3(0, 0, 0));
  }
}

ResourcesManager.ts file:
import gsap from "gsap";
import * as THREE from "three";
import { FontLoader } from "three/examples/jsm/loaders/FontLoader";

import EventEmitter from "./EventEmitter";
import Experience from "../Experience";

export enum SourceType {
  Texture = "texture",
  Font = "font",
}

export interface Source {
  type: SourceType;
  path: string;
  name: string;
}

interface Loaders {
  textureLoader: THREE.TextureLoader;
  fontLoader: FontLoader;
}

export default class ResourcesManager extends EventEmitter {
  private readonly _sources: Source[];
  private _overlay: THREE.Mesh;
  private _loaders: Loaders;
  readonly items: Record<string, any>;

  constructor(sources: Source[]) {
    super();

    this._sources = sources;
    this.items = {};

    this.setOverlay();
    this.setLoaders();
    this.startLoading();
  }

  private setOverlay() {
    const { camera, scene } = Experience.getInstance();
    const overlayGeometry = new THREE.PlaneGeometry(100, 100);
    const overlayMaterial = new THREE.MeshBasicMaterial({
      color: 0x000000,
      transparent: true,
    });
    this._overlay = new THREE.Mesh(overlayGeometry, overlayMaterial);
    this._overlay.position.z = camera.instance.position.z - 0.4;
    scene.add(this._overlay);
  }

  private setLoaders() {
    const loadingBarElement = document.getElementById(
      "loading-bar"
    ) as HTMLElement;

    const loadingManager = new THREE.LoadingManager(
      () => {
        this.trigger("ready");

        gsap.to(this._overlay.material, { duration: 3, opacity: 0, delay: 1 });

        gsap.delayedCall(1, () => {
          loadingBarElement.classList.add("ended");
          loadingBarElement.style.transform = "";
        });
      },
      // @ts-ignore
      (itemUrl, itemsLoaded, itemsTotal) => {
        loadingBarElement.style.transform = `scaleX(${
          itemsLoaded / itemsTotal
        })`;
      },
      (error) => {
        console.error(error);
      }
    );

    this._loaders = {
      textureLoader: new THREE.TextureLoader(loadingManager),
      fontLoader: new FontLoader(loadingManager),
    };
  }

  private startLoading() {
    for (const source of this._sources) {
      if (source.type === SourceType.Texture) {
        this._loaders.textureLoader.load(source.path, (file) => {
          this.sourceLoaded(source, file);
        });
      } else if (source.type === SourceType.Font) {
        this._loaders.fontLoader.load(source.path, (file) => {
          this.sourceLoaded(source, file);
        });
      }
    }
  }

  private sourceLoaded(source: Source, file: any) {
    this.items[source.name] = file;
  }
}

World.ts file:
import DateText from "./DateText";
import Environment from "./Environment";
import Moon from "./Moon";
import MoonData from "./MoonData";
import NextDayButton from "./NextDayButton";
import PhaseText from "./PhaseText";
import PrevDayButton from "./PrevDayButton";
import Stars from "./Stars";
import Experience from "../Experience";

export default class World {
  private static instance: World | null = null;
  moonData: MoonData;
  moon: Moon;
  phaseText: PhaseText;
  dateText: DateText;
  nextDayButton: NextDayButton;
  prevDayButton: PrevDayButton;
  stars: Stars;
  environment: Environment;

  private constructor() {
    if (World.instance) {
      return World.instance;
    }

    World.instance = this;

    const { resourcesManager } = Experience.getInstance();

    this.moonData = new MoonData();

    // Wait for resources loading
    resourcesManager.on("ready", () => {
      this.moon = new Moon();
      this.phaseText = new PhaseText();
      this.dateText = new DateText();
      this.nextDayButton = new NextDayButton();
      this.prevDayButton = new PrevDayButton();
      this.stars = new Stars();
      this.environment = new Environment();

      // New Date event
      this.moonData.on("newDate", () => {
        this.updateData();
      });

      // Previous Day event
      this.prevDayButton.on("prevDay", () => {
        this.prevDay();
      });

      // Next Day event
      this.nextDayButton.on("nextDay", () => {
        this.nextDay();
      });
    });
  }

  static getInstance(): World {
    if (!World.instance) {
      World.instance = new World();
    }
    return World.instance;
  }

  updateData(): void {
    this.phaseText.updateData();
    this.environment.updateData();
    this.dateText.updateData();
  }

  resize(): void {
    this.phaseText.resize();
    this.dateText.resize();
    this.moon.resize();
    this.prevDayButton.resize();
    this.nextDayButton.resize();
  }

  nextDay(): void {
    this.moonData.nextDay();
    this.updateData();
  }

  prevDay(): void {
    this.moonData.prevDay();
    this.updateData();
  }
}

Moon.ts file:
import * as THREE from "three";

import Experience from "../Experience";

export default class Moon {
  private debugFolder: any;
  private geometry: THREE.SphereGeometry;
  private material: THREE.MeshStandardMaterial;
  private mesh: THREE.Mesh;

  constructor() {
    this.setDebug();
    this.setGeometry();
    this.setMaterial();
    this.setMesh();
    this.resize();
  }

  private setDebug(): void {
    const { debugUi } = Experience.getInstance();

    if (debugUi.active) {
      this.debugFolder = debugUi.ui?.addFolder("Moon");
    }
  }

  private setGeometry(): void {
    this.geometry = new THREE.SphereGeometry(2, 250, 250);
  }

  private setMaterial(): void {
    const { resourcesManager } = Experience.getInstance();

    const textures = {
      color: resourcesManager.items.moonColorTexture,
      bump: resourcesManager.items.moonBumpTexture,
    };

    this.material = new THREE.MeshStandardMaterial({
      map: textures.color,
      bumpMap: textures.bump,
    });

    this.material.bumpScale = 0.04;

    this.debugFolder
      ?.add(this.material, "bumpScale")
      .min(0)
      .max(1)
      .step(0.01)
      .name("bump scale");
  }

  private setMesh(): void {
    const { scene } = Experience.getInstance();

    this.mesh = new THREE.Mesh(this.geometry, this.material);
    this.mesh.rotation.y = 4.5;

    scene.add(this.mesh);
  }

  resize(): void {
    const { viewportManager } = Experience.getInstance();

    if (viewportManager.size.width < 400) {
      this.mesh.scale.set(0.8, 0.8, 0.8);
    } else if (viewportManager.size.width < 600) {
      this.mesh.scale.set(0.85, 0.85, 0.85);
    } else {
      this.mesh.scale.set(1, 1, 1);
    }
  }
}



Based on the data that I provided help me to solve the following issue: