Here are all the info about the current project that I'm working on:

# Moon Sight Documentation

Moon Sight is a web application that displays a 3D model of the moon in its current phase and allows users to change the date while updating the model. The application is built using TypeScript classes, Vite, Three.js for 3D rendering, GSAP for animations, and Tailwind CSS for styling.

## Table of Contents

1. [Overview](#overview)
2. [Tech Stack](#tech-stack)
3. [Key Components](#key-components)
4. [Tasks](#tasks)

## Overview

The Moon Sight web application is designed to provide users with an interactive 3D model of the moon in its current phase. Users can change the date to see how the moon's phase changes over time. The application is built using a combination of modern web technologies and libraries, such as TypeScript, Vite, Three.js, GSAP, and Tailwind CSS.

## Tech Stack

The following technologies and libraries are used in the Moon Sight project:

1. **TypeScript**: TypeScript is a typed superset of JavaScript that compiles to plain JavaScript. It provides static typing and other features to improve the development experience.
2. **Vite**: Vite is a fast build tool and development server for modern web applications. It optimizes the build process and provides features such as hot module replacement for a fast development experience.
3. **Three.js**: Three.js is a JavaScript library used for creating and displaying 3D graphics in the browser using WebGL. In this project, it is used to create the 3D model of the moon and its phases.
4. **GSAP**: GreenSock Animation Platform (GSAP) is a powerful JavaScript library for creating high-performance animations. In this project, it is used to animate the loading bar and other elements.
5. **Tailwind CSS**: Tailwind CSS is a utility-first CSS framework that allows developers to build responsive and modern designs quickly. It is used for styling the application.

## Key Components

The Moon Sight application consists of several key components:

1. **Experience**: This is the main class responsible for initializing the application and managing various components, such as the camera, renderer, resources manager, and world.
2. **Camera**: The Camera class handles the creation and configuration of the Three.js camera instance used to view the 3D scene.
3. **Renderer**: The Renderer class is responsible for managing the WebGL renderer and updating the scene based on user interactions and animations.
4. **ResourcesManager**: This class is responsible for loading and managing resources, such as textures and fonts, required for the application.
5. **World**: The World class is responsible for creating and managing the 3D moon model and handling user interactions with the model.

## Tasks

- Check Orientation Device Sensor
- Refactor World Classes
- Improve World Classes

Here are some example files of the project:

Experience.ts file:
import * as THREE from "three";

import Camera from "./Camera";
import Renderer from "./Renderer";
import sources from "./sources";
import DebugUi from "./utils/DebugUi";
import ResourcesManager from "./utils/ResourcesManager";
import StatsPanel from "./utils/StatsPanel";
import TimeManager from "./utils/TimeManager";
import ViewportManager from "./utils/ViewportManager";
import World from "./world/World";

let instance: Experience | null = null;

export default class Experience {
  canvas: HTMLCanvasElement;
  debugUi: DebugUi;
  statsPanel: StatsPanel;
  viewportManager: ViewportManager;
  timeManager: TimeManager;
  scene: THREE.Scene;
  camera: Camera;
  resourcesManager: ResourcesManager;
  renderer: Renderer;
  world: World;

  constructor() {
    if (instance) return instance;
    // eslint-disable-next-line @typescript-eslint/no-this-alias
    instance = this;

    this.debugUi = new DebugUi();
    this.statsPanel = new StatsPanel();
    this.viewportManager = new ViewportManager();
    this.timeManager = new TimeManager();
    this.scene = new THREE.Scene();
    this.camera = new Camera();
    this.resourcesManager = new ResourcesManager(sources);
    this.renderer = new Renderer();
    this.world = new World();

    this.initializeCanvas();
    this.registerEventListeners();
  }

  initializeCanvas() {
    this.canvas = document.getElementById("main-canvas") as HTMLCanvasElement;
    if (!this.canvas) {
      throw new Error("Could not find or create a canvas element.");
    }
  }

  registerEventListeners() {
    this.viewportManager.on("resize", () => this.resize());
    this.timeManager.on("tick", () => this.update());
  }

  resize(): void {
    this.camera.resize();
    this.renderer.resize();
    // this.world.resize();
  }

  update(): void {
    if (this.statsPanel.active) this.statsPanel.instance?.begin();

    this.camera.update();
    this.renderer.update();

    if (this.statsPanel.active) this.statsPanel.instance?.end();
  }
}

Camera.ts file:
import * as THREE from "three";

import Experience from "./Experience.js";

export default class Camera {
  instance: THREE.PerspectiveCamera;

  constructor() {
    const { viewportManager } = Experience.getInstance();

    this.instance = new THREE.PerspectiveCamera(
      45,
      viewportManager.viewport.size.width /
        viewportManager.viewport.size.height,
      0.1,
      100
    );

    this.setInstance();
  }

  private setInstance() {
    const { scene } = Experience.getInstance();

    this.instance.position.z = 10;
    scene.add(this.instance);
  }

  resize() {
    const { viewportManager } = Experience.getInstance();

    this.instance.aspect =
      viewportManager.viewport.size.width /
      viewportManager.viewport.size.height;
    this.instance.updateProjectionMatrix();
  }

  update() {
    const { timeManager, viewportManager } = Experience.getInstance();

    if (viewportManager.cursor.position.x) {
      this.instance.position.x +=
        (viewportManager.cursor.position.x - this.instance.position.x) *
        0.005 *
        timeManager.delta;
    } else if (
      viewportManager.viewport.orientation.x ||
      viewportManager.viewport.orientation.y
    ) {
      this.instance.position.x +=
        (viewportManager.viewport.orientation.x - this.instance.position.x) *
        0.01 *
        timeManager.delta;
      this.instance.position.y +=
        (viewportManager.viewport.orientation.y - this.instance.position.y) *
        0.005 *
        timeManager.delta;
    }
    this.instance.lookAt(new THREE.Vector3(0, 0, 0));
  }
}

ResourcesManager.ts file:
import gsap from "gsap";
import * as THREE from "three";
import { FontLoader } from "three/examples/jsm/loaders/FontLoader";

import EventEmitter from "./EventEmitter";
import Experience from "../Experience";

export enum SourceType {
  Texture = "texture",
  Font = "font",
}

export interface Source {
  type: SourceType;
  path: string;
  name: string;
}

interface Loaders {
  textureLoader: THREE.TextureLoader;
  fontLoader: FontLoader;
}

export default class ResourcesManager extends EventEmitter {
  private readonly _sources: Source[];
  private _overlay: THREE.Mesh;
  private _loaders: Loaders;
  readonly items: Record<string, any>;

  constructor(sources: Source[]) {
    super();

    this._sources = sources;
    this.items = {};

    this.setOverlay();
    this.setLoaders();
    this.startLoading();
  }

  private setOverlay() {
    const { camera, scene } = Experience.getInstance();
    const overlayGeometry = new THREE.PlaneGeometry(100, 100);
    const overlayMaterial = new THREE.MeshBasicMaterial({
      color: 0x000000,
      transparent: true,
    });
    this._overlay = new THREE.Mesh(overlayGeometry, overlayMaterial);
    this._overlay.position.z = camera.instance.position.z - 0.4;
    scene.add(this._overlay);
  }

  private setLoaders() {
    const loadingBarElement = document.getElementById(
      "loading-bar"
    ) as HTMLElement;

    const loadingManager = new THREE.LoadingManager(
      () => {
        this.trigger("ready");

        gsap.to(this._overlay.material, { duration: 3, opacity: 0, delay: 1 });

        gsap.delayedCall(1, () => {
          loadingBarElement.classList.add("ended");
          loadingBarElement.style.transform = "";
        });
      },
      // @ts-ignore
      (itemUrl, itemsLoaded, itemsTotal) => {
        loadingBarElement.style.transform = `scaleX(${
          itemsLoaded / itemsTotal
        })`;
      },
      (error) => {
        console.error(error);
      }
    );

    this._loaders = {
      textureLoader: new THREE.TextureLoader(loadingManager),
      fontLoader: new FontLoader(loadingManager),
    };
  }

  private startLoading() {
    for (const source of this._sources) {
      if (source.type === SourceType.Texture) {
        this._loaders.textureLoader.load(source.path, (file) => {
          this.sourceLoaded(source, file);
        });
      } else if (source.type === SourceType.Font) {
        this._loaders.fontLoader.load(source.path, (file) => {
          this.sourceLoaded(source, file);
        });
      }
    }
  }

  private sourceLoaded(source: Source, file: any) {
    this.items[source.name] = file;
  }
}

Based on the documentation and the provided files <---------REQUEST--------->